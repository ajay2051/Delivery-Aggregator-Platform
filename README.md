# This project processes delivery requests and tracks delivery status throughout its lifecycle.
It supports role-based access control, idempotent request handling, asynchronous background tasks with Celery, and is fully Dockerized with a clean Git workflow.


# Features

Delivery lifecycle tracking (CREATED, IN_TRANSIT, COMPLETED, FAILED)
Role-based access (Admin, Partner)
Idempotent delivery request creation (prevents duplicates)
Asynchronous processing using Celery
Email / notification support via background tasks
Docker & Docker Compose support
Clean Git workflow for team collaboration

# Tech Stack

Backend: Django, Django REST Framework
Async Tasks: Celery, Redis
Database: PostgreSQL (or SQLite for local)
Containerization: Docker, Docker Compose
Documentation: Swagger (drf-yasg)

# Project Setup
https://github.com/ajay2051/Delivery-Aggregator-Platform
cd delivery_aggregator_platform

# Create Environment File
Check sample.env 

# Running Without Docker (Local)
# Create Virtual Environment
python -m venv venv
source venv/bin/activate

# Install Dependencies
pip install -r requirements.txt

# Apply Migrations
python manage.py makemigrations
python manage.py migrate

# Swagger Docs
http://127.0.0.1:8000/api/v1/docs/

# To start Celery tasks
celery -A project worker  --loglevel=INFO
celery -A project worker flower

# Running with Docker (Recommended)
# Build and Start Containers
docker compose up --build

# To Stop Containers
docker compose down --rmi all


# Idempotency Key

To prevent duplicate records caused by repeated API calls (e.g. retries, double submissions, or network timeouts), the system uses an idempotency key.
The idempotency key is deterministically generated by hashing a combination of:
The authenticated userâ€™s ID
The request payload (sorted and normalized)
A fixed prefix to scope the operation (e.g. delivery)
Because the same user submitting the same data will always generate the same idempotency key, repeated requests are safely identified.
Before creating a new record, the API checks whether a record with the same idempotency key already exists:
If it exists, the existing record is returned instead of creating a duplicate
If it does not exist, a new record is created and stored with the generated key
This approach ensures safe retries, duplicate prevention, and consistent behavior across distributed systems.