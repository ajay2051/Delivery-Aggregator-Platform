# This project processes delivery requests and tracks delivery status throughout its lifecycle.
It supports role-based access control, idempotent request handling, asynchronous background tasks with Celery, and is fully Dockerized with a clean Git workflow.


# Features

Delivery lifecycle tracking (CREATED, IN_TRANSIT, COMPLETED, FAILED)
Role-based access (Admin, Partner)
Idempotent delivery request creation (prevents duplicates)
Asynchronous processing using Celery
Email / notification support via background tasks
Docker & Docker Compose support
Clean Git workflow for team collaboration

# Tech Stack

Backend: Django, Django REST Framework
Async Tasks: Celery, Redis
Database: PostgreSQL (or SQLite for local)
Containerization: Docker, Docker Compose
Documentation: Swagger (drf-yasg)

# Project Setup
https://github.com/ajay2051/Delivery-Aggregator-Platform
cd delivery_aggregator_platform

# Create Environment File
Check sample.env 

# Running Without Docker (Local)
# Create Virtual Environment
python -m venv venv
source venv/bin/activate

# Install Dependencies
pip install -r requirements.txt

# Apply Migrations
python manage.py makemigrations
python manage.py migrate

# Swagger Docs
http://127.0.0.1:8000/api/v1/docs/

# To start Celery tasks
celery -A project worker -l info -n worker1@%h -Q celery (Starts Celery with unique name)
celery -A project worker  --loglevel=INFO
celery -A project worker flower

# Running with Docker (Recommended)
# Build and Start Containers
docker compose up --build

# To Stop Containers
docker compose down --rmi all

# Run tests
python manage.py test


# Idempotency Key

To prevent duplicate records caused by repeated API calls (e.g. retries, double submissions, or network timeouts), the system uses an idempotency key.
The idempotency key is deterministically generated by hashing a combination of:
The authenticated user’s ID
The request payload (sorted and normalized)
A fixed prefix to scope the operation (e.g. delivery)
Because the same user submitting the same data will always generate the same idempotency key, repeated requests are safely identified.
Before creating a new record, the API checks whether a record with the same idempotency key already exists:
If it exists, the existing record is returned instead of creating a duplicate
If it does not exist, a new record is created and stored with the generated key
This approach ensures safe retries, duplicate prevention, and consistent behavior across distributed systems.

# Delivery Assignment, Status Updates & Notifications
Assign Delivery

Super Admins can assign a delivery to an Admin user.
When a delivery is assigned:
The assigned_to field is updated
Delivery status transitions from CREATED → ASSIGNED
A notification is sent to the assigned admin informing them about the delivery

# Update Delivery Status
Admin users can update delivery status while strictly following the delivery state machine:
CREATED → ASSIGNED
ASSIGNED → IN_TRANSIT
IN_TRANSIT → COMPLETED / FAILED
COMPLETED and FAILED are terminal states and cannot be updated further
Invalid transitions are automatically rejected to maintain lifecycle integrity.

# Notifications

The system sends asynchronous notifications for key delivery events:
When a delivery is assigned to an admin
When delivery status changes (e.g., IN_TRANSIT, COMPLETED, FAILED)
Notifications are handled via background tasks to ensure non-blocking API performance and reliable delivery updates to users.